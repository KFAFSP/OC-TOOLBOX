local E=math.huge;local F=computer.uptime;local G=false local H=setmetatable({head=1,tail=0},{__len=function(a)return a.tail-a.head+ 1 end})local function I(a)H.tail=H.tail+1;H[H.tail]=a end local function J() local a,b=H.head,H.tail;if a>b then return nil end;local c=H[a]H[a],H.head=nil,a+1 if a==b then H.head,H.tail=1,0 end;return c end local function K(a)local b={computer.pullSignal(a or 0)}if #b>0 and not(G and b[1]== "redstone_changed")then I(b)end end local L=setmetatable({},{__index=function()return 0 end}) local M={__len=function(a)return#a.data*2 end,__index=function(a,b) local c=a.data:byte(math.ceil(b/2))or 0x00 if b%2 ==0 then c=bit32.rshift(c,4)else c=bit32.band(c,0xF)end;return c end,__newindex=function(a,b,c)local c,d=bit32.band(c,0xF),math.ceil( b/2) local e=string.byte(a.data,d)or 0x00 if b%2 ==0 then e=bit32.bor(bit32.band(e,0xF),bit32.lshift(c,4))else e=bit32.bor(bit32.band(e,0xF0),c)end a.data=a.data:sub(1,d-1)..string.char(e)..a.data:sub(d+1)end}local function N(a,b) return setmetatable({bsize=#a.data,data=b or""},M)end local function O(a,b,c) local d,e=a.dvc.getBundledInput(a.side)if b~=nil then c=c or 1 for e=1,#a.data do b[c+e-1]=d[a.data[e]]end end;return d[a.ctrl]end local function P(a,b,c,d)d,c=d or 0,c or L;local e,f={[a.ctrl]=b}for f=1,#a.data do e[a.data[f]]=c[d+f-1]end;a.dvc.setBundledOutput(a.side,e)end;local function Q(a,b,c,...) local d={dvc=a,side=b,ctrl=c,data={...},rcvbuf=E,sndbuf=E,rcvto=E,sndto=E}P(d,0)return 0,d end local function R(a,b,c) P(a,0)c,b=c or a.sndto,N(a,b) local d,e,f,g=math.min(#b,a.sndbuf),O(a),F()if e~=0 then return-2 end;P(a,1) while true do K()e=O(a)if e==2 then break elseif e==1 and F()-f>=c then return-10 elseif e~=1 then return-3,e end end;local h=#a.data for g=1,d,h do P(a,4+ (g%2),b,g)if g%10 ==0 then K()end end;P(a,6)P(a,0)return d end local function S(a,b,c)P(a,0)b,c=b or a.rcvto,c or a.rcvbuf;local d,e,f,g=O(a),F(),N(a),1;if d~=0 and d~=1 then return-2 end while true do if d==1 then P(a,2)d=2;break elseif d==0 and F()-e>=b then return-10 elseif d~=0 then return-3,d end;d=O(a)K()end while true do d=O(a,f,(g-1)*f.bsize+1) if d==4+ (g%2)then g=g+1 elseif (d==4)or(d==5)then elseif d==6 then break elseif d~=-2 then return-3,d end;if g%10 ==0 then K()end end f.data=f.data:sub(1,math.ceil(g*f.bsize/2)-1)return#f.data,f.data end;local function T(a) return component.proxy(component.list(a)())end;local U=T("eeprom")local V=U.getData() local W,X={}for X in V:gmatch("([^;]*);")do table.insert(W,X)end local Y,Z=tonumber(W[1]),W[2] local ba,bb,bc,bd=tonumber(W[3]),tonumber(W[4]),tonumber(W[5]),{}local be;for be=1,bc do bd[be]=tonumber(W[5+be])end local bf,bg=Q(T("redstone"),ba,bb,bc,table.unpack(bd))local bh=T("modem")bh.open(Y) while true do local a,b,c=J() while a==nil do K(0.1)a=J()end if a[1]=="redstone_changed"and a[3]==ba and not G then G=true;b,c=S(bg,0.5)P(bg,0)G=false if b>0 then bh.broadcast(Y,c)end elseif a[1]=="modem_message"and a[3]:sub(1,#Z)==Z and a[4]==Y then I({"relay",a[6]})elseif a[1]=="relay"and not G then G=true b,bf=R(bg,a[2],1)P(bg,0)G=false;if b<0 then I(a)end end end